//////////////////////////////////////////////////
// TITLE Gradle Build Script
//////////////////////////////////////////////////

import groovy.json.JsonBuilder
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import net.minecraftforge.gradle.user.TaskSourceCopy

import static java.io.File.separator

/* SECTION build script */

buildscript {
    repositories {
        jcenter()
        maven {
            //noinspection SpellCheckingInspection
            name = 'Minecraft Forge'
            url = 'https://files.minecraftforge.net/maven'
        }
    }

    dependencies {
        //noinspection SpellCheckingInspection
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.+'
    }
    // COMMENT Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
}


/* SECTION all projects */

configurations {
    debug {
        canBeResolved false
        canBeConsumed false
    }
    runtimeOnly.extendsFrom debug
}

allprojects {
    /* SECTION extra variables */

    ext {
        utilitiesDir = "$rootDir${separator}gradle${separator}utilities"
        modulesDir = "$utilitiesDir${separator}modules"
    }


    /* SECTION application */

    apply from: "$modulesDir${separator}plugins.gradle"

    apply from: "$utilitiesDir${separator}miscellaneous.gradle"
    apply from: "$utilitiesDir${separator}globals.gradle"
    apply from: "$utilitiesDir${separator}collections.gradle"
    apply from: "$utilitiesDir${separator}strings.gradle"
    apply from: "$utilitiesDir${separator}io${separator}io.gradle"
    apply from: "$utilitiesDir${separator}io${separator}properties${separator}properties.gradle"
    apply from: "$utilitiesDir${separator}io${separator}properties${separator}ext.properties.gradle"


    /* SECTION extra variables */

    loadExt "$projectDir${separator}module.properties"


    /* SECTION configuration */

    apply from: "$modulesDir${separator}versioning.gradle"
    apply from: "$modulesDir${separator}information.gradle"

    apply from: "$modulesDir${separator}configurations.gradle"
    apply from: "$modulesDir${separator}repositories.gradle"
    apply from: "$modulesDir${separator}dependencies.gradle"

    apply from: "$modulesDir${separator}source.gradle"
    apply from: "$modulesDir${separator}resources.gradle"
    apply from: "$modulesDir${separator}javadoc.gradle"
    tasks.withType(TaskSourceCopy) { enabled false }

    apply from: "$modulesDir${separator}test.gradle"
    apply from: "$modulesDir${separator}jar.gradle"

    apply from: "$modulesDir${separator}ide.gradle"


    // COMMENT append
    afterEvaluate { storeExt() }
}


apply from: "$utilitiesDir${separator}throwable.gradle"

/* SECTION extra variables */

loadExt "$rootDir${separator}buildSrc${separator}ext-ra.properties", true

ext {
    // COMMENT game

    minecraftVersion = (minecraftForgeVersion as String).split('-').first()
    //noinspection SpellCheckingInspection
    String[] minecraftVersions = (minecraftVersion as String).split('\\.')
    minecraftMajor = minecraftVersions.first().toInteger()
    minecraftMinor = minecraftVersions[1].toInteger()
    minecraftVersionRange = "[$minecraftMajor.$minecraftMinor,$minecraftVersion]".toString()


    // COMMENT mod

    modId = project.name
}

/* SECTION application */

apply from: "$modulesDir${separator}optional${separator}minecraft-forge.gradle"
// TODO (Optional) Move the main project for a multi-project build.
apply from: "$modulesDir${separator}optional${separator}mod.gradle"


/* SECTION configuration */

if (hasProperty('lastGoodSettingsJson')) {
    gradle.afterProject { Project p ->
        Object json = new JsonSlurper().parseText(lastGoodSettingsJson)
        try {
            json.projects?."$path"?.dependencies?.each { config ->
                config?.value?.each { dep ->
                    if (!config.key.startsWith('forgeGradle')) {
                        p.dependencies.add config.key as String, [group: dep.group, name: dep.name, version: dep.version], { force true }
                        p.logger.debug "Dependecy overriding with: configuration: $config.key, group: $dep.group, name: $dep.name, version: $dep.version"
                    }
                }
            }
        } catch (Exception e) {
            caughtThrowable e
            p.logger.log LogLevel.WARN, "'$lastGoodSettingsPath' may be corrupted", e
        }
    }
}

afterEvaluate {
    Project pSub = project(subprojectMain)
    if (pSub != project) {
        evaluationDependsOn subprojectMain
        tasks.each {
            Task tSub = pSub.tasks.findByName(it.name)
            if (tSub != null) {
                it.enabled false
                it.dependsOn tSub
            }
        }
    }
}

gradle.buildFinished { BuildResult r ->
    if (r.failure == null) {
        // COMMENT save last good settings
        logger.info 'Saving last good settings...'

        Wrapper wrapper = tasks.wrapper as Wrapper
        Map<String, Object> json = [
                gradle   : [distributionUrl: wrapper.distributionUrl.replace(wrapper.distributionType.name().toLowerCase(Locale.ROOT), Wrapper.DistributionType.ALL.name().toLowerCase(Locale.ROOT))],
                minecraft: [
                        version : minecraftForgeVersion,
                        mappings: minecraftMappings
                ],
                projects : [:]
        ]
        allprojects.each { project ->
            Map<String, Object> jsonProject = json.projects."$project.path" = [
                    dependencies: [:]
            ]
            configurations.each { configuration ->
                List<Object> jsonConfiguration = jsonProject.dependencies."$configuration.name" = []
                if (configuration.canBeResolved) configuration.resolvedConfiguration.firstLevelModuleDependencies.each { if (it.moduleGroup != null && it.moduleName != 'unspecified' && it.moduleVersion != null) jsonConfiguration << [group: it.moduleGroup, name: it.moduleName, version: it.moduleVersion] }
                else configuration.dependencies.each { if (it.group != null && it.name != 'unspecified' && it.version != null) jsonConfiguration << [group: it.group, name: it.name, version: it.version] }
            }
        }
        String jsonText = new JsonBuilder(json).toString()

        createNewFileFromPath(lastGoodSettingsPath).write jsonText
        logger.info '{}:{}{}', convertToCanonicalPath(lastGoodSettingsPath), System.lineSeparator(), JsonOutput.prettyPrint(jsonText)
    }

    // COMMENT clean cache
    logger.info 'Cleaning cache...'

    // COMMENT Gradle
    gradle.gradleUserHomeDir.eachDir { it.eachDirMatch(~/[0-9]+[.-][0-9.+-]+/) { if (it.name != gradle.gradleVersion) delete it } }

    // COMMENT Minecraft
    //noinspection SpellCheckingInspection
    String minecraftCachePath = "$gradle.gradleUserHomeDir.absolutePath${separator}caches${separator}minecraft"
    // COMMENT Minecraft Coder Pack
    File mcpDir = file "$minecraftCachePath${separator}de${separator}oceanlabs${separator}mcp${separator}mcp_snapshot"
    if (mcpDir.exists()) mcpDir.eachDir { if ("snapshot_$it.name".toString() != minecraftMappings) delete it }
    // COMMENT Minecraft Forge
    //noinspection SpellCheckingInspection
    File minecraftForgeDir = file "$minecraftCachePath${separator}net${separator}minecraftforge${separator}forge"
    if (minecraftForgeDir.exists()) minecraftForgeDir.eachDir { if (it.name != minecraftForgeVersion) delete it }
}
