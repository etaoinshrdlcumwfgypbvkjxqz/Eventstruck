//////////////////////////////////////////////////
// TITLE Gradle Build Script
//////////////////////////////////////////////////

import groovy.json.JsonBuilder

import java.util.regex.Pattern

import static java.io.File.separator


/* SECTION build script */

buildscript {
    repositories {
        jcenter()
        maven {
            name = 'Minecraft Forge'
            url = 'https://files.minecraftforge.net/maven'
        }
    }

    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.+'
    }
    // COMMENT Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
}


/* SECTION application */

plugins {
    id 'java'
    id 'scala'
    id 'eclipse'
    id 'idea'
}
apply plugin: 'net.minecraftforge.gradle.forge'

apply from: "$rootDir${separator}gradle${separator}utilities.gradle"
apply from: "$rootDir${separator}gradle${separator}global.gradle"
apply from: "$rootDir${separator}gradle${separator}io${separator}properties${separator}properties.gradle"
apply from: "$rootDir${separator}gradle${separator}io${separator}properties${separator}ext.properties.gradle"


/* SECTION extension variables */

loadExt "$rootDir${separator}buildSrc${separator}ext.properties"

ext {
    // COMMENT game

    minecraftVersion = (minecraftForgeVersion as String).split('-').first()
    minecraftVersions = (minecraftVersion as String).split('\\.')
    minecraftMajor = minecraftVersions.first().toInteger()
    minecraftMinor = minecraftVersions[1].toInteger()
    minecraftVersionRange = "[${minecraftMinor == 0 ? minecraftMajor - 1 : minecraftMajor}.${minecraftMinor == 0 ? Integer.MAX_VALUE : minecraftMinor - 1},$minecraftVersion]"


    // COMMENT versioning

    majorMod = majorMod.toInteger()
    majorApi = majorApi.toInteger()
    minor = minor.toInteger()
    patch = patch.toInteger()
    this.'final' = this.'final'.toBoolean()
    pre = pre.toBoolean()
    releaseCandidate = releaseCandidate.toInteger()
    if (this.'final' && pre) throw new IllegalArgumentException('"final" and "pre" are both "true"!')
    if ((this.'final' || pre) && releaseCandidate != 0) throw new IllegalArgumentException("'${this.'final' ? 'final' : 'pre'}' is 'true' while 'releaseCandidate' is not '0' but '$releaseCandidate'.")


    // COMMENT mod

    authorList = stringToStringList authorList_
    screenshots = stringToStringList screenshots_
    requiredMods = stringToStringList requiredMods_
    dependencies = stringToStringList dependencies_
    dependants = stringToStringList dependants_

    StringBuilder cdSb = new StringBuilder()
    requiredMods.each { cdSb.append "required:$it;" }
    ext.dependencies.each {
        if (cdSb.contains(it as String)) cdSb.replaceFirst Pattern.quote("required:$it"), "required-after:$it"
        else cdSb.append "after:$it;"
    }
    dependants.each {
        if (cdSb.contains(m as String)) cdSb.replaceFirst Pattern.quote("required:$it"), "required-before:$it"
        else cdSb.append "before:$it;"
    }
    combinedDependencies = cdSb.append(combinedDependenciesAdditions).toString()
}


/* SECTION repositories */

repositories {
    gradlePluginPortal()
    jcenter()
    mavenCentral()
    google()
}

stringToStringMap(customRepositories).each { String k, List<String> v -> v.each {
    String[] e = it.split('(?<!\\\\):', 2).collect { evaluateGStringString it.trim().replace('\\:', ':') }
    repositories."$k" {
        name = e.first()
        url = e.last()
    }
}}


/* SECTION configuration */

version = "${minecraftVersion}-${majorMod}.${majorApi}.${minor}.${patch}${project.ext.'final' ? '-final' : pre ? '-beta' : releaseCandidate != 0 ? "-rc$releaseCandidate" : ''}"
group = group_ // COMMENT http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = project.name
description = description_

// COMMENT Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = 1.8


eclipse {
    classpath {
        downloadSources = downloadJavadoc = true
    }
}
idea {
    module {
        downloadSources = downloadJavadoc = true
    }
}


//noinspection SpellCheckingInspection
minecraft {
    version = minecraftForgeVersion
    runDir = runDir

    // COMMENT the mappings can be changed at any time, and must be in the following format.
    // COMMENT snapshot_YYYYMMDD   snapshot are built nightly.
    // COMMENT stable_#            stables are built at the discretion of the MCP team.
    // COMMENT Use non-default mappings at your own risk. they may not always work.
    // COMMENT simply re-run your setup task after changing the mappings to update your workspace.
    mappings = minecraftMappings
    // COMMENT makeObfSourceJar = false // COMMENT an Srg named sources jar is made by default. uncomment this to disable.
}


configurations {
    shade
    compile.extendsFrom shade

    debug
    compileOnly.extendsFrom debug
}


//noinspection SpellCheckingInspection
dependencies {
    // COMMENT you may put jars on which you depend on in ./libs
    // COMMENT or you may define them like so..
    // CODE compile 'some.group:artifact:version:classifier'
    // CODE compile 'some.group:artifact:version'

    // COMMENT real examples
    // CODE compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // CODE compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // COMMENT the 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // CODE provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // COMMENT the deobf configurations:  'deobfCompile' and 'deobfProvided' are the same as the normal compile and provided,
    // COMMENT except that these dependencies get remapped to your current MCP mappings
    // CODE deobfCompile 'com.mod-buildcraft:buildcraft:6.0.8:dev'
    // CODE deobfProvided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // COMMENT for more info...
    // COMMENT http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // COMMENT http://www.gradle.org/docs/current/userguide/dependency_management.html

    /* COMMENT
    'compile' is superseded by 'implementation'.
    'provided' is superseded by 'compileOnly'.
    'runtime' is superseded by 'runtimeOnly'.
     */
}
stringToStringMap(customDependencies).each { String k, List<String> v -> v.each { dependencies.add k, evaluateGStringString(it) } }


sourceSets {
    main
    test
    api
}

static <E> String processResourcesList(List<E> l) { l.empty ? '[]' : l.toListString().replace('[', '["').replace(']', '"]').replace(', ', '", "') }

new ArrayList<>(tasks).each { t ->
    String name = t.name
    if (name.endsWith('Java') && name.startsWith('source')) { // COMMENT sourceJava
        t.enabled = false
        String sourceSetName = name.replace('source', '').replace('Java', '').uncapitalize()
        String taskSourceSetName = sourceSetName == 'main' ? '' : sourceSetName.capitalize()

        Task process = task("process${name.capitalize()}", type: ProcessResources, description: "Process $sourceSetName Java.") {
            inputs.property 'expand_modId', project.name
            inputs.property 'expand_name', name_
            inputs.property 'expand_version', version
            inputs.property 'expand_dependencies', combinedDependencies
            inputs.property 'expand_minecraftVersionRange', minecraftVersionRange
            inputs.property 'expand_certificateFingerprint', certificateFingerprint
            inputs.property 'expand_updateJSON', updateJSON
            inputs.property 'expand_group', project.group

            into t.output

            from(temporaryDir) {
                Map<String, Object> e = [:]
                inputs.properties.each { if (it.key.startsWith('expand_')) {
                    String k = it.key.replace('expand_', '')
                    e.put k, it.value
                    e.put "${k}__".toString(), it.value
                }}

                expand e

                Binding eb = new Binding(e)
                eachFile {
                    File f = file "$temporaryDir.absolutePath$separator$it.sourcePath"
                    f.text = f.text.replaceAll(~/\$(.*?)__/) { "\${${it[1]}}" }
                    it.path = evaluateGStringStringWithBinding it.path, eb
                }
            }
        }
        t.finalizedBy process

        Task preProcess = task("preProcess${name.capitalize()}", type: Sync, description: "Prepare sources for processing $sourceSetName Java.") {
            from t.source as FileCollection
            into process.temporaryDir
        }
        Task postProcess = task("postProcess${name.capitalize()}", type: Jar, description: "Finalize after processing $sourceSetName Java.") {
            from process.destinationDir as File
            classifier sourceSetName
            destinationDir = file "$buildDir/debug"

            createNewFile archivePath
            dependencies."${"${taskSourceSetName}Compile".uncapitalize()}" files(archivePath)
        }
        process.dependsOn preProcess
        process.finalizedBy postProcess
    } else if (name.endsWith('Resources') && name.startsWith('process')) { // COMMENT processResources
        String taskSourceSetName = name.replace('process', '').replace('Resources', '')
        String sourceSetName = (taskSourceSetName.empty ? 'main' : taskSourceSetName).uncapitalize()

        t.configure {
            // COMMENT this will ensure that this task is redone when the variables change.
            inputs.property 'expand_modId', project.name
            inputs.property 'expand_name', name_
            inputs.property 'expand_description', project.description
            inputs.property 'expand_version', version
            inputs.property 'expand_minecraftVersion', project.minecraft.version
            inputs.property 'expand_url', url
            inputs.property 'expand_updateUrl', updateUrl
            inputs.property 'expand_updateJSON', updateJSON
            inputs.property 'expand_authorList', processResourcesList(authorList as List<String>)
            inputs.property 'expand_credits', credits
            inputs.property 'expand_logoFile', logoFile
            inputs.property 'expand_screenshots', processResourcesList(screenshots as List<String>)
            inputs.property 'expand_parent', parent_
            inputs.property 'expand_requiredMods', processResourcesList(requiredMods as List<String>)
            inputs.property 'expand_dependencies', processResourcesList(project.ext.dependencies as List<String>)
            inputs.property 'expand_dependants', processResourcesList(dependants as List<String>)
            inputs.property 'expand_pack_format', pack_format

            Map<String, Object> e = inputs.properties.findAll { it.key.startsWith 'expand_' }.collectEntries { [it.key.replace('expand_', ''), it.value] } as Map<String, Object>

            // COMMENT replace stuff in the to-be-processed files, nothing else
            from(sourceSets."$sourceSetName".resources.srcDirs) {
                include '**/*.in'
                rename ~/(.*)\.in/, '$1'

                // COMMENT replace variables
                expand e
            }

            // COMMENT copy everything else except the processed files
            from(sourceSets."$sourceSetName".resources.srcDirs) {
                exclude '**/*.in'
            }

            Binding eb = new Binding(e)
            eachFile { it.path = evaluateGStringStringWithBinding it.path, eb }
        }

        Task sync = task("sync${name.capitalize()}", type: Sync, description: "Sync $sourceSetName resources.") {
            from t.destinationDir as File
            into tasks."compile${taskSourceSetName}Java".destinationDir
            preserve { include '**/*.class' }
        }
        t.finalizedBy sync

        Task before = task("before${taskSourceSetName}Jar", description: "Prepare $sourceSetName stuff for jaring.") {
            mustRunAfter sync
            doLast {
                sourceSets."$sourceSetName".allSource.srcDirs.each { it.mkdir() }
                delete fileTree(dir: sync.destinationDir, excludes: ['**/*.class'])
            }
        }
        tasks.jar.dependsOn before
    }
}


test {
    useJUnitPlatform()
    testLogging {
        events 'started', 'passed', 'skipped', 'failed', 'standard_out', 'standard_error'
    }
}


jar {
    configurations.shade.each { from (zipTree(it)) { exclude 'META-INF', 'META-INF/**' }}
}

reobf {
    //noinspection SpellCheckingInspection
    jar {
        // COMMENT extraLines 'PK: org/ejml your/new/package/here/ejml' // COMMENT shading example
    }
}

stringToStringMap(customDependencies).each { if (it.key == 'shade') it.value.each {
    String p = evaluateGStringString(it as String).split(":", 2).first().replace '.', '/'
    reobf.jar.extraLines "PK: $p ${group.replace '.', '/'}/shaded/$p"
}}


task deobfJar(type: Jar, dependsOn: 'jar') {
    from sourceSets.main.java.outputDir
    classifier 'dev'
}

/* CODE
task sourceJar(type: Jar, dependsOn: 'sourceMainJava') {
    from sourceSets.main.allSource
    classifier 'sources'
}
*/

task javadocJar(type: Jar, dependsOn: 'javadoc') {
    from tasks.javadoc.destinationDir
    classifier 'javadoc'
}

tasks.each { if (it instanceof org.gradle.jvm.tasks.Jar) {
    it.exclude { it.directory ? it.path.contains('$') : it.path.endsWith('.in') }
    artifacts.archives it
} }


tasks.runClient.outputs.upToDateWhen { false }
tasks.runServer.outputs.upToDateWhen { false }


task saveCurrentGoodSettings(group: 'build', description: "Saves current good settings to '$lastGoodSettingsPath'.") {
    outputs.file lastGoodSettingsPath

    doLast {
        File file = file lastGoodSettingsPath
        createNewFile file

        Wrapper wrapper = tasks.wrapper as Wrapper
        Map<String, Object> json = [
                gradle: [ distributionUrl: wrapper.distributionUrl.replace(wrapper.distributionType.name().toLowerCase(Locale.ROOT), Wrapper.DistributionType.ALL.name().toLowerCase(Locale.ROOT)) ],
                dependencies: [],
                minecraft: [
                        version: minecraftForgeVersion,
                        mappings: minecraftMappings
                ]
        ]
        configurations.each { configuration ->
            if (configuration.canBeResolved) configuration.resolvedConfiguration.firstLevelModuleDependencies.each { json.dependencies.add([configuration: configuration.name, group: it.moduleGroup, name: it.moduleName, version: it.moduleVersion]) }
            else configuration.dependencies.each { json.dependencies.add([configuration: configuration.name, group: it.group, name: it.name, version: it.version]) }
        }
        String jsonText = new JsonBuilder(json).toPrettyString()

        file.write jsonText
        logger.info "'${convertToCanonicalPath lastGoodSettingsPath}':"
        logger.info jsonText
    }
}
tasks.build.finalizedBy tasks.saveCurrentGoodSettings


//noinspection SpellCheckingInspection
task cleanCacheAutomatically(type: Delete, group: 'build', description: 'Clean old items from cache to reduce space usage.', dependsOn: tasks.saveCurrentGoodSettings) {
    // COMMENT Gradle

    gradle.gradleUserHomeDir.eachDir { it.eachDirMatch(~/[0-9]+[.-][0-9.+-]+/) { if (it.name != gradle.gradleVersion) delete it } }


    // COMMENT Minecraft

    //noinspection SpellCheckingInspection
    String minecraftCachePath = "$gradle.gradleUserHomeDir.absolutePath${separator}caches${separator}minecraft"


    // COMMENT Minecraft Coder Pack
    File mcpDir = file "$minecraftCachePath${separator}de${separator}oceanlabs${separator}mcp${separator}mcp_snapshot"
    if (mcpDir.exists()) mcpDir.eachDir { if ("snapshot_$it.name".toString() != minecraftMappings) delete it }


    // COMMENT Minecraft Forge

    //noinspection SpellCheckingInspection
    File minecraftForgeDir = file "$minecraftCachePath${separator}net${separator}minecraftforge${separator}forge"
    if (minecraftForgeDir.exists()) minecraftForgeDir.eachDir { if (it.name != minecraftForgeVersion) delete it }
}
tasks.saveCurrentGoodSettings.finalizedBy tasks.cleanCacheAutomatically


storeExt()
